import { useState, useCallback, useEffect, useRef } from 'react';
import { apiService } from '../services/api';

export interface RequestHistoryData {
  id: number;
  method: string;
  url: string;
  month: string;
  day: string;
  year: string;
  time: string;
  created_at: string;
}

export const useRequestHistory = () => {
  const [history, setHistory] = useState<RequestHistoryData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const isMounted = useRef(true);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  // Fetch history from backend
  const fetchHistory = useCallback(async () => {
    if (!isMounted.current) {
      console.log('Component not mounted, skipping fetch');
      return;
    }
    
    console.log('\n=== Starting to fetch history ===');
    setLoading(true);
    setError(null);
    
    try {
      console.log('Calling apiService.getHistory()...');
      const response = await apiService.getHistory();
      console.log('API Response:', {
        hasItems: !!response?.items,
        itemCount: response?.items?.length || 0,
        firstItem: response?.items?.[0] || 'No items'
      });
      
      if (!isMounted.current) {
        console.log('Component unmounted during fetch, aborting...');
        return;
      }
      
      if (response && response.items && Array.isArray(response.items)) {
        console.log('Transforming items...');
        
        const transformedItems = response.items.map(item => {
          const createdAt = item.created_at ? new Date(item.created_at) : new Date();
          const transformed = {
            id: item.id || 0,
            method: item.method || 'GET',
            url: item.url || '',
            month: item.month || String(createdAt.getMonth() + 1).padStart(2, '0'),
            day: item.day || String(createdAt.getDate()).padStart(2, '0'),
            year: item.year || String(createdAt.getFullYear()),
            time: item.time || createdAt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            created_at: item.created_at || createdAt.toISOString()
          };
          console.log('Transformed item:', transformed);
          return transformed;
        });

        console.log('Setting history state with items:', transformedItems.length);
        setHistory(transformedItems);
      } else {
        console.error('Unexpected response format:', response);
        setError('Received invalid data from server');
        setHistory([]);
      }
    } catch (err) {
      console.error('Error in fetchHistory:', err);
      if (isMounted.current) {
        setError('Failed to fetch history');
        setHistory([]);
      }
    } finally {
      if (isMounted.current) {
        setLoading(false);
      }
    }
  }, []);

  // Initial fetch and set up auto-refresh
  useEffect(() => {
    console.log('useEffect - Initial fetch');
    fetchHistory();

    // Set up auto-refresh
    const intervalId = setInterval(() => {
      console.log('Auto-refreshing history...');
      fetchHistory();
    }, 5000);

    // Cleanup interval on unmount
    return () => {
      console.log('Cleaning up history interval');
      clearInterval(intervalId);
    };
  }, [fetchHistory]);

  // Save a new request to history
  const saveRequest = useCallback(async (requestData: Omit<RequestHistoryData, 'id' | 'created_at'>) => {
    try {
      // Create the data to save with required fields
      const dataToSave: RequestHistoryData = {
        ...requestData,
        id: 0, // Will be generated by the database
        created_at: new Date().toISOString()
      };
      
      console.log('Saving request to history:', dataToSave);
      const response = await apiService.saveRequest(dataToSave);
      
      if (!isMounted.current) return { success: false, error: 'Component unmounted' };
      
      if (response.success) {
        console.log('Request saved successfully, refreshing history...');
        // Refresh the history after saving
        await fetchHistory();
        return { success: true };
      } else {
        throw new Error(response.error || 'Failed to save request');
      }
    } catch (err) {
      if (!isMounted.current) return { success: false, error: 'Component unmounted' };
      
      const errorMessage = err instanceof Error ? err.message : 'An error occurred';
      console.error('Error saving request:', errorMessage, err);
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  }, [fetchHistory]);

  // Load history when component mounts and when fetchHistory changes
  useEffect(() => {
    console.log('useEffect - Fetching history...');
    fetchHistory();
    
    // Set up a refresh interval (every 5 seconds) - optional
    const intervalId = setInterval(() => {
      console.log('Auto-refreshing history...');
      fetchHistory();
    }, 5000);
    
    // Clean up interval on unmount
    return () => clearInterval(intervalId);
  }, [fetchHistory]);

  return {
    history,
    loading,
    error,
    saveRequest,
    refreshHistory: fetchHistory
  };
};
